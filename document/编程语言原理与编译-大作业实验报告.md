# 2021-2022学年第2学期

# **大 作 业 实 验 报 告**

![zucc](https://plc-sigcc.vercel.app/lab/zucc.png)

- 课程名称：编程语言原理与编译

- 实验项目：期末大作业

- 专业班级：<u>计算1902、计算1902</u>

- 学生学号：<u>31901060、31901039</u>

- 学生姓名：<u>张亦骞、蔡海龙</u>

- 实验指导教师：郭鸣

  

## **实验内容**

### **一、评分方式，以下为起始评分**

- 按 及格 中 良 优 参考计分，最终看完成水平。

  ```
  60 70 80 90
  ```

  - [参考任务](https://gitee.com/sigcc/plzoofs/blob/master/microc/task.md)

- 优秀

  - 参与实际的开源编译器项目
    - v rust julia 等
  - 自行完整实现一个较复杂的语言
    - 生成 中间语言、汇编
    - 实现高级的语言特性
      - 按特性实现难度给分

- 良 完整实现一个简单语言

  - 词法/语法/语义检查，中间代码IR,栈式虚拟机

- 中 实现一个简单语言

  - 实现 词法/语法/语义（类型检查，中间语言AST,IR）

- 及格 修改实现一个简单语言

  - 修改 现有项目 简单的词法/语法，必须理解原来的代码
  - 实现需要包括解释器和编译器



### **二、完成文档为md格式，请预览并确保格式正确**

- 缩进，代码，图片，突出显示 的正确markdown语法
- 翻译专业词汇标准，请到图书馆查找相关翻译的编译书籍，部分书籍有专业术语表。
  - columbia
  - PLC
  - ssw
  - yale



### **三、提交内容**

- 项目报告
  - 文档结构 [参考项目结构](https://bb.zucc.edu.cn/bbcswebdav/users/j04014/PLC/final/columbia.microc.llvm.proj.rar)
- 项目源代码（测试代码）
- [参考项目](https://bb.zucc.edu.cn/bbcswebdav/users/j04014/PLC/final21)



### **四、建议改进列表（可选择其中部分加以改进）**

#### **1、词法部分**

- 修改注释的表示方式，如：
  - (* *)
  - //
  - /* */
- 修改常量定义
  - 字符串常量 （参考python语法）
    - 单引号' ' 双引号 "" 三引号 '''
  - 数值常量 （参考c语法）
    - 二进制 0b0101，八进制0o777，十六进制0xFFDA
- 修改标识符定义
  - 类型名称：以大写开头
  - 变量名：以小写开头
  - 两个下划线开头的名字__是内部保留，不允许

#### 2、语法部分

- if的多种方式
  - switch case
- 循环的多种方式
  - for / while / do while/ until
- ? : 表达式 (C语言)
- for in 表达式
- 匿名 lambda 函数（参考Python 或 Javascript）

#### **3、语义部分**

- 类型检查，类型推理
- 支持嵌套函数
- 动态作用域，静态作用域
- 闭包支持
- 模式匹配支持
- 中间代码生成 AST，四元式，三元式，llvm
- 生成器 generator, yield
- 协程 coroutine



### **五、其他参考实现语言项目**

- 命令式语言 NanoC
- 对象式语言 NanoJ
- 函数式语言 NanoF
- 逻辑式语言 NanoL



### **六、项目分工表格**

| 姓名   | 学号     | 班级     | 任务                                               | 权重 |
| ------ | -------- | -------- | -------------------------------------------------- | ---- |
| 蔡海龙 | 31901039 | 计算1902 |                                                    | 0.95 |
| 张亦骞 | 31901060 | 计算1902 | 自增自减，三目运算符，复合赋值运算符，变量初始化， | 0.95 |



### **七、成员代码提交日志**

![](https://plc-sigcc.vercel.app/lab/commit.png)



### **八、项目自评等级（1-5）**

​		请根据自己项目情况填写下表。

| 词法                                               |   评分   |                         备注                         |
| :------------------------------------------------- | :------: | :--------------------------------------------------: |
| 注释 (* *)                                         |          |                                                      |
| 注释 /**/                                          |          |                                                      |
| 注释 //                                            |          |                                                      |
| 字符串常量 单引号' '                               |          |                                                      |
| 字符串常量 双引号 ""                               |          |                                                      |
| 字符串常量 三引号 '''                              |          |                                                      |
| 数值常量 二进制0b0101                              |          |                                                      |
| 数值常量 八进制0o777                               |          |                                                      |
| 数值常量 十六0xFFDA                                |          |                                                      |
| 修改标识符定义 类型名称：以大写开头                |          |                                                      |
| 修改标识符定义 变量名：以小写开头                  |          |                                                      |
| 修改标识符定义  __不可作为变量名开头（遇到则报错） |          |                                                      |
|                                                    |          |                                                      |
| **语法**                                           | **评分** |                       **备注**                       |
| 变量初始化（定义变量时同时赋初值）                 |    3     |                未实现全局变量的初始化                |
| if的多种方式                                       |    5     | if ifelse ifelseif为microc自带。实现不带else的if语句 |
| switch case                                        |          |                                                      |
| 循环 for                                           |          |   尝试实现初始化表达式为语句的for循环，但未能实现    |
| 循环 while                                         |          |                      microc自带                      |
| 循环 do while                                      |          |                                                      |
| 循环 until                                         |          |                                                      |
| 三目运算 ? :      (C语言)                          |    5     |                                                      |
| for in 表达式                                      |    3     |  编译器部分暂时不能实现同时输出存在正序和逆序的情况  |
| 匿名 lambda 函数（参考Python或js）                 |          |                                                      |
| 前置自增、前置自减                                 |    5     |                                                      |
| 后置自增、后置自减                                 |    5     |                                                      |
| 复合赋值运算符+=  -=  *=  /=  %=                   |    5     |                                                      |
|                                                    |          |                                                      |
| **变量类型**                                       | **评分** |                       **备注**                       |
| float类型                                          |          |                                                      |
| double类型                                         |          |                                                      |
| string类型                                         |          |                                                      |
| boolean类型                                        |          |                                                      |
|                                                    |          |                                                      |
| **语义**                                           | **评分** |                       **备注**                       |
| 动态作用域                                         |          |                                                      |
| 静态作用域                                         |          |                                                      |
| 闭包支持                                           |          |                                                      |
| 模式匹配支持                                       |          |                                                      |
| 中间代码生成 AST，四元式，三元式，llvm             |          |                                                      |
| 生成器 generator, yield                            |          |                                                      |
|                                                    |          |                                                      |



### **九、功能实现步骤（以前置自增为例）**

#### **1、解释器部分**

（1）在Absyn.fs中定义抽象语法

```F#
and expr =                           // 表达式，右值                     
  | PreInc of access                                           //自增 ++i or ++a[e]
```

（2）在CPar.fsy中添加词元说明符token和该token的用法

​		添加词元说明符token：

```
//%token是词元说明符
...
%token PREINC           //前置自增
...
```

```F#
%right ASSIGN             /* 最低优先级 */  // 最下面的优先级最高
...
%left TIMES DIV MOD       //乘 除 取余
%nonassoc NOT AMP PREINC         //!取反 &取地址 前置自增
%nonassoc LBRACK          /* 最高优先级  */  //左括号

//这里要注意添加的关键字的优先级，优先级高的放下面，优先级低的放上面
```

​		添加用法：

```
  //非左值的情况
ExprNotAccess:
...
  | PREINC Access                       { PreInc $2      }  // 前置自增++a
...
;
```

（3）在CLex.fsl中添加该token

```F#
rule Token = parse          // 每个 规则rule 会生成为一个函数，函数名是规则名 Token
...
  | "++"            { PREINC }    //前置自增
...

//注意这里++是两个字符，所以要用双引号，不能用单引号
```

（4）在Interp.fs中添加该token的实现

```F#
and eval e locEnv gloEnv store : int * store =
    match e with
    ...
    | PreInc acc -> //前置自增
        let (loc, store1) as res = access acc locEnv gloEnv store //取要求的acc的地址和环境
        let res = getSto store1 loc //得到要求的这个acc在store1的loc位置上的值
        (res + 1, setSto store1 loc (res + 1)) //把值加一后set到store中，元组左边返回的就是这个加一后的值
    ...

```



#### **2、编译器部分**

（1）在Absyn.fs中定义抽象语法【即解释器部分的（1）】

（2）若需要添加汇编指令，在Machine.c中添加【前置自增未用到新的指令，故省略该步骤】

（3）在Comp.fs中添加相应的实现

```F#
//编译右值表达式
and cExpr (e: expr) (varEnv: VarEnv) (funEnv: FunEnv) : instr list =
    match e with
	...
	| PreInc acc -> cAccess acc varEnv funEnv @ [ DUP; LDI; CSTI 1; ADD; STI ]//前置自增
	...
```



### **十、运行工程使用到的执行命令**

#### **1、解释器部分（12条命令）**

```sh
dotnet restore interpc.fsproj #可选
dotnet clean interpc.fsproj #可选
dotnet build interpc.fsproj #构建./bin/Debug/net6.0/interpc.exe，并查看详细生成过程
./bin/Debug/net6.0/interpc.exe zyq_example/preinc.c #查看运行结果
dotnet "C:\Users\82444\.nuget\packages\fslexyacc\10.2.0\build\/fslex/netcoreapp3.1\fslex.dll" -o "CLex.fs" --module CLex --unicode CLex.fsl #生成扫描器
dotnet "C:\Users\82444\.nuget\packages\fslexyacc\10.2.0\build\/fsyacc/netcoreapp3.1\fsyacc.dll" -o "CPar.fs" --module CPar CPar.fsy #生成分析器
dotnet fsi #进入命令行
					 #注：以下代码在终端的fsi中运行
#r "nuget: FsLexYacc";; //添加包引用
#load "Absyn.fs" "Debug.fs" "CPar.fs" "CLex.fs" "Parse.fs" "Interp.fs" "ParseAndRun.fs" ;;
open ParseAndRun;;
fromFile "zyq_example/preinc.c";; #查看preinc.c语法树
run (fromFile "zyq_example/preinc.c") [];; #解释执行preinc.c
```

#### **2、编译器部分（6条命令）**

```sh
gcc -o machine.exe machine.c #生成c虚拟机
dotnet restore microc.fsproj #可选
dotnet clean microc.fsproj #可选
dotnet build microc.fsproj #构建./bin/Debug/net6.0/microc.exe
dotnet run --project microc.fsproj zyq_example/preinc.c
.\machine.exe -trace zyq_example/preinc.out 0 #追踪查看运行栈
```



### **十一、项目说明**

#### **1、重要参考图片【非常重要】**

![](img\svm.png)

<img src="img\machine.png" style="zoom:80%;" />

<img src="img\stack.png" style="zoom:80%;" />



#### **2、项目概述**

​		本项目是基于现有的microc代码。



#### **3、实现 前置自增、前置自减、后置自增、后置自减**

1、Absyn.fs

![1](/img/添加步骤示例/1.png)

2、CPar.fsy

![](/img/添加步骤示例/2.png)

![](/img/添加步骤示例/3.png)

![](/img/添加步骤示例/4.png)

3、CLex.fsl

![](/img/添加步骤示例/5.png)

4、Interp.fs（解释器）

![](/img/添加步骤示例/6.png)

![](/img/添加步骤示例/7.png)

5、Comp.fs（编译器）



6、语法树



7、解释运行



8、追踪查看运行栈



preinc：

```c
//前置自增
void main() {
  int x;
  x = 3;
  print x;
  ++x;
  print x;
}
```

preinc语法树：

![](/img/preinc/7.png)



#### 4、实现 (* *)注释

CLex.fsl中添加如下代码

```fsharp
rule Token = parse
	| "(* "            { Comment lexbuf; Token lexbuf }
and Comment = parse
	| "(* "           { Comment lexbuf; Comment lexbuf }
   	| "*)"           { () }
```

运行命令

```shell
./bin/Debug/net6.0/interpc.exe .\chl_exampale\ex1.c
```

测试代码

```C
void main(){
    int x;
    x = 3;
    //print x
    x++;
    /*print x*/
    x++;
    (* faskdlfj*)
    print x;
}
```

运行结果

![image-20220526211140209](img/image-20220526211140209.png)

查看AST

```
dotnet run -p interpc.fsproj .\chl_exampale\ex1.c -g
```

![image-20220526213338965](img/image-20220526213338965.png)

#### **5、实现 二进制`0b`、八进制`0o`、十进制、十六进制`0x`数值常量**

CLex.fsl

```fsharp
// 2进制转换函数
let bin2Dec value=
    let rec binaryToList value n =
        match value%10 with
        | _ when value%10 >= 0 && value%10 < 2 -> if value=0 then n else binaryToList (value/10) ((value%10)::n)
        | _        -> failwith "Does not conform to binary number type."
    let rec pow n =
        if n=0 then 1
        else 2 * (pow (n-1))
    let rec len xs =
        match xs with
        | []-> 0
        | x::xr->1 + len xr
    let rec eval (n: int list) =
        match n with
        | [] -> 0
        | xr::yr -> xr * pow (len yr) + eval yr
    eval (binaryToList value [])
// 8进制转换函数
let oct2Dec value=
    let rec octalToList value n =
        match value%10 with
        | _ when value%10 >= 0 && value%10 < 8 -> if value=0 then n else octalToList (value/10) ((value%10)::n)
        | _        -> failwith "Does not conform to octal number type."
    let rec pow n =
        if n=0 then 1
        else 8 * (pow (n-1))
    let rec len xs =
        match xs with
        | []-> 0
        | x::xr->1 + len xr
    let rec eval (n: int list) =
        match n with
        | [] -> 0
        | xr::yr -> xr * pow (len yr) + eval yr
    eval (octalToList value [])
// 16进制转换函数
let hex2Dec value = 
    let rec hexaToList (str:string)  = 
        if(str.Length <= 0) then []
        else
            match str.[0] with
            | _ when str.[0] >='a' && str.[0] <= 'f'    -> (int str.[0]) - ( int 'a') + 10::hexaToList str.[1..str.Length - 1]
            | _ when str.[0] >= 'A' && str.[0] <= 'F'   -> (int str.[0]) - ( int 'A') + 10::hexaToList str.[1..str.Length - 1]
            | _ when str.[0] >= '0' && str.[0] <= '9'   -> (int str.[0]) - ( int '0') ::hexaToList str.[1..str.Length - 1]
            | _                                         -> failwith "Does not conform to hex number type."
    let result = hexaToList (value)
    let mutable num = 0;
    List.iter(fun i -> num <- num*16 + i)result
    num

let binHexOct (s:string) =
    match s.[0..1] with
    | "0B"
    | "0b"
    | "0O"
    | "0o"
    | "0X"
    | "0x" ->   s.[2..(s.Length)-1] 
    | _    ->   failwith "Lexer error: no such radix"
rule Token = parse    
    | "0"['B''b']['0'-'1']+                { CSTINT (bin2Dec(System.Int32.Parse (binHexOct (lexemeAsString lexbuf))))}    
  | "0"['O''o']['0'-'7']+                { CSTINT (oct2Dec(System.Int32.Parse (binHexOct (lexemeAsString lexbuf)))) }
  | "0"['X''x']['0'-'9''A'-'F''a'-'f']+  {CSTINT (hex2Dec(binHexOct (lexemeAsString lexbuf)))}  
```

测试代码

```
//16/8/2进制
void main(){
    int a;
    a=0x10;
    int b;
    b=0O10;
	int c;
    c=0b1010;

	print a;
	print b;
    print c;
}
```

执行结果

![image-20220526232827077](img/image-20220526232827077.png)



#### **6、实现 三目运算符**





#### **7、实现 复合赋值运算符**





#### **8、实现** 变量初始化

1、Absyn.fs

```F#
// 顶级声明 可以是函数声明或变量声明
and topdec = 
  | VardecAndAssign of typ * string * expr //全局变量初始化（声明的时候就赋值）
```

```F#
//语句或声明
and stmtordec =
  | DecAndAssign of typ * string * expr  //局部变量初始化（声明的时候就赋值）
```

2、CPar.fsy

```fsy
Topdec:
  | VardecAndAssign SEMI                { VardecAndAssign (first $1,second $1,third $1) } //变量初始化
;
```

```
// 变量初始化
VardecAndAssign:
    Type Vardesc ASSIGN Expr            { ((fst $2) $1, snd $2, $4)}  //格式是：   变量类型 变量描述 赋值符号 表达式
;
```

```
// 语句块中的 语句 或 序列
StmtOrDecSeq:                 //最后的StmtOrDecSeq表示可以多个语句在一个语句后面
  | VardecAndAssign SEMI StmtOrDecSeq   { DecAndAssign (first $1, second $1, third $1) :: $3 } //局部变量初始化
  //first second third是从第一个位置上的VardecAndAssign取出元素
;
```

3、Interp.fs（解释器）

```F#
(* 构建变量和函数的全局环境。对于全局变量，存储位置是保留的；对于全局函数，只需添加到全局函数环境。 *)
//初始化 解释器环境和store
let initEnvAndStore (topdecs: topdec list) : locEnv * funEnv * store =

    //包括全局函数和全局变量
    msg $"\ntopdecs:\n{topdecs}\n"

    //构造全局环境
    let rec addv decs locEnv funEnv store =
        match decs with
        ...//其他的代码
        
        // 全局变量初始化：调用 allocate 在store上给变量分配空间
        | VardecAndAssign (typ, x, expr) :: decr ->
            let (locEnv1, sto1) = allocate (typ, x) locEnv store //分配空间
            addv decr locEnv1 funEnv sto1

    // ([], 0) []  默认全局环境
    // locEnv ([],0) 变量环境 ，变量定义为空列表[],下一个空闲地址为0
    // ([("n", 1); ("r", 0)], 2)  表示定义了 变量 n , r. 下一个可以用的变量索引是 2
    // funEnv [] 函数环境，函数定义为空列表[]
    addv topdecs ([], 0) [] emptyStore
```

```F#
and stmtordec stmtordec locEnv gloEnv store =
    match stmtordec with
    | DecAndAssign (typ, x, expr) -> //局部变量初始化
        let (locEnv1 ,store1) = allocate (typ, x) locEnv store //调用allocate函数，
                                                               //为类型为typ的变量x在局部环境和store上分配空间，
                                                               //这里返回的locEnv1就是该变量的局部环境
        let (loc, store2) = access (AccVar x) locEnv1 gloEnv store1 //计算左值变量x的地址和更新过的store
        let (res, store3) = eval expr locEnv gloEnv store2 //计算表达式expr，返回值和更新过的store
        (locEnv1, setSto store3 loc res) //返回局部环境locEnv，把expr的值赋值给store3在loc位置上的变量，也就是赋值给变量x
```

4、Comp.fs（编译器）

​		首先，把makeGlobalEnvs函数移植到cAccess函数上面，并把let改为and，让makeGlobalEnvs函数和cAccess等函数处于同一级。因为不移动makeGlobalEnvs函数的位置，会无法使用cAccess函数，从而无法后去变量var的汇编指令列表。

```F#
(* 为全局变量和函数构建环境 *)
and makeGlobalEnvs (topdecs: topdec list) : VarEnv * FunEnv * instr list =
    let rec addv decs varEnv funEnv =

        msg $"\nGlobal funEnv:\n{funEnv}\n"

        match decs with
        | [] -> (varEnv, funEnv, [])
        | dec :: decr ->
            match dec with
            ...//其他的代码
            
            | VardecAndAssign (typ, var, expr) -> //变量初始化
                let (varEnv1, code1) = allocateWithMsg Glovar (typ, var) varEnv //调用allocateWithMsg函数为全局变量分配空间
                let (varEnvr, funEnvr, coder) = addv decr varEnv1 funEnv //在上一行得到的新变量环境中返回变量环境和函数环境
                let code2 = cAccess (AccVar var) varEnvr funEnvr //获得左值变量var的汇编指令列表
                (varEnvr, funEnvr, code1 @ coder @ code2)

    addv topdecs ([], 0) []
```

```F#
//语句 或 声明
and cStmtOrDec stmtOrDec (varEnv: VarEnv) (funEnv: FunEnv) : VarEnv * instr list =
    match stmtOrDec with
    ...//其他的代码
    
    | DecAndAssign (typ, x, expr) ->
        let (varEnv1,code) = allocateWithMsg Locvar (typ, x) varEnv //调用allocateWithMsg函数为局部变量分配空间
        let (code2) = cExpr (Assign (AccVar x, expr)) varEnv1 funEnv //获取表达式expr给该变量x赋值的汇编指令
        let res = code @ code2 @ [INCSP -1] //返回varEnv1这个变量环境 和 两个汇编指令列表的拼接，最后释放空间
        (varEnv1, res)
```

```F#
let cProgram (Prog topdecs) : instr list =
    ...//其他的代码

    let functions =
        List.choose
            (function
            ...//其他的代码
            
            | VardecAndAssign _ -> None) //变量初始化
            topdecs

    ...//其他的代码
```

5、测试代码

```c
//变量初始化
// int a=3;
void main() {
  // print a;
  int c=4;
  int b=--c;
  print b;
}
```

6、查看语法树

![](/img/decandassign/1.png)

7、解释执行

![](/img/decandassign/2.png)

8、追踪查看运行栈

![](/img/decandassign/3.png)



#### **9、实现for循环**

一般在print后[INCSP -1]，cExpr后若无判断，一般有[INCSP -1]。

1、Absyn



#### **10、实现 for-in-range函数**

本来要实现for(i in arr){}这样的格式，在尝试后决定从python的for-in-range入手。

| ForInExpr of access * expr * stmt  【原来的】

| ForInExpr of access * expr * expr * expr 【后来】

在写解释器的时候，发现运行结果一直没有退出循环，最终发现是每次的循环判断条件没有设置为当前的开始下标+步进值，即正确的应该是：

`let judge = v2-(step+v3) //循环条件：结束下标-(当前起始下标+步进值)`



编译器部分：把forinrange函数转换为for函数。

```
for(i in range(1,5,2)){
  body;
}
```

等价于：

```
for(i=1;i<5;i+=2){
  body;
}

acc:i   e1:i=1  e2:i<5   e3:i+=2
```









### **十二、解决技术要点说明**

##### **1、解决 变量初始化 问题， 关键代码与步骤如下**

​		



##### **2、解决 xxx 问题2， 关键代码与步骤如下**

​		



### **十三、心得体会（结合自己情况具体说明）**

#### **1、大项目开发过程心得**

- **遇到哪些困难，经历哪里过程，有哪些收获**

  <u>**张亦骞：**</u>
  
  1、汇编指令【编译器部分】
  
  2、变量初始化
  
  3、for循环的通常用法【未实现】
  
  for(int i=0;i<3;i++)
  
  
  
  
  
  <u>**蔡海龙：**</u>
  
  
  
  
  
  

#### **2、本课程建议**

- **课程难度方面，进度方面，课程内容，授课方式等，给出你的意见**

  <u>**张亦骞：**</u>
  
  
  
  
  
  <u>**蔡海龙：**</u>
  
  
  
  
  
  